from datetime import datetime
import autograd.numpy as np
import capytaine as cpy
import matplotlib.pyplot as plt
from scipy.optimize import brute
import wecopttool as wot

Mensity = 5
z = np.linspace(-4,-5.2,Mensity)
x = 35*(z+4)/6 + 10
y = 35*(z+4)/6 +10
xyz = np.array([np.array([x,y,z]) for x,y,z in zip(x,y,z)])
Frustum = cpy.FloatingBody(cpy.AxialSymmetricMesh.from_profile(xyz))

w = np.linspace(0,-5.2,Mensity)
u = 3-w+w
v = 3-w+w
uvw = np.array([np.array([u,v,w]) for u,v,w in zip(u,v,w)])
Arr = cpy.FloatingBody(cpy.AxialSymmetricMesh.from_profile(uvw))
Arr+=Frustum

t = np.linspace(0,-4,Mensity)
r = 10-t+t
s = 10-t+t
rst = np.array([np.array([r,s,t]) for r,s,t in zip(r,s,t)])
ArrEm = cpy.FloatingBody(cpy.AxialSymmetricMesh.from_profile(rst))
ArrEm+= Arr

q = np.linspace(0,0,Mensity)
o = 3-7*t/4
p = 3-7*t/4
opq = np.array([np.array([o,p,q]) for o,p,q in zip(o,p,q)])
ArrEmThree = cpy.FloatingBody(cpy.AxialSymmetricMesh.from_profile(opq))
ArrEmThree+=ArrEm

def inner_function(f_max = 2000.0, p_max = 100.0, v_max = 10000.0, mesh = rm3,
    wavefreq = 0.3, amplitude = 1):
    if mesh == rm3:
        fb = ArrEmThree
    else:
        fb = cpy.FloatingBody.from_meshio(mesh, name="WaveBot")
    fb.add_translation_dof(name="Heave")
    ndof = fb.nb_dofs
    stiffness = wot.hydrostatics.stiffness_matrix(fb).values
    mass = wot.hydrostatics.inertia_matrix(fb).values
    f1 = 0.05
    nfreq = 50
    freq = wot.frequency(f1, nfreq, False) # False -> no zero frequency
    bem_data = wot.run_bem(fb, freq)
    name = ["PTO_Heave",]
    kinematics = np.eye(ndof)
    controller = None
    loss = None
    pto_impedance = None
    pto = wot.pto.PTO(ndof, kinematics, controller, pto_impedance, loss, name)
    f_add = {'PTO': pto.force_on_wec}
    nsubsteps = 4
    def const_f_pto(wec, x_wec, x_opt, waves): # Format for scipy.optimize.minimize
        f = pto.force_on_wec(wec, x_wec, x_opt, waves, nsubsteps)
        return f_max - np.abs(f.flatten())
    def const_p_pto(wec, x_wec, x_opt, waves): # Format for scipy.optimize.minimize
        p = pto.position(wec, x_wec, x_opt, waves, nsubsteps)
        return p_max - np.abs(p.flatten())
    def const_v_pto(wec, x_wec, x_opt, waves): # Format for scipy.optimize.minimize
        v = pto.velocity(wec, x_wec, x_opt, waves, nsubsteps)
        return v_max - np.abs(v.flatten())
    ineq_cons1 = {'type': 'ineq',
                 'fun': const_f_pto,
                 }
    ineq_cons2 = {'type': 'ineq',
                 'fun': const_p_pto,
                 }
    ineq_cons3 = {'type': 'ineq',
                 'fun': const_v_pto,
                 }
    constraints = [ineq_cons1,ineq_cons2,ineq_cons3]
    wec = wot.WEC.from_bem(
        bem_data,
        inertia_matrix=mass,
        hydrostatic_stiffness=stiffness,
        constraints=constraints,
        friction=None,
        f_add=f_add,)
    phase = 30
    wavedir = 0
    waves = wot.waves.regular_wave(f1, nfreq, wavefreq, amplitude, phase, wavedir)


    obj_fun = pto.mechanical_average_power
    nstate_opt = 2*nfreq


    options = {'maxiter': 200}
    scale_x_wec = 1e1
    scale_x_opt = 1e-3
    scale_obj = 1e-2
    results = wec.solve(
        waves,
        obj_fun,
        nstate_opt,
        optim_options=options,
        scale_x_wec=scale_x_wec,
        scale_x_opt=scale_x_opt,
        scale_obj=scale_obj,
        )
    return results.fun
    